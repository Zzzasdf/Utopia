/// ******************* 内存分析示例 *******************

using System;

// 类是引用，内部的字段 一定 都在 堆上
public class ClassExample
{
    private int a; // 内存空间
    private Tuple<int> b; // 引用
    
    private int[] c; // 引用
    private Tuple<int>[] d; // 引用 
    
    public void Foo()
    {
        a = 1; // 值类型的赋值操作，不涉及 新内存
        b = new Tuple<int>(5); // 在堆上，开辟一块内存，存放类的字段，
        c = new int[5]; // 在堆上，开辟一块连续内存，直接存放 值类型
        d = new Tuple<int>[5]; // 在堆上，开辟一块连续内存，存放数组的引用，对 item 赋值时，等号右边是一块新内存，数组的引用指向这块内存
    }
}

// 结构体是值类型，内部字段的位置需要根据 外部调用处 来决定，
// 如果一路上都是结构体，那么 当前结构体字段 一定 在 栈上
// 如果一路上存在类，那么 当前结构体字段 一定 在 堆上
// 结构体的优势：
//  1、少一层引用
//  2、使用数组时
//      结构体：new 时， 是一块连续 直接 存放值的内存，
//          实际存放的内存连续，一大块的，所以命中率高
//      引用类型：new 时，是一块连续存放 引用 的内存，实际存放 还需要 new 一个新的内存 才能 存放 item
//          只是引用内存连续，item 依旧时单独的，小块小块组合的，所以命中率低
// 结构体劣势：
//  1、实际存放数据的大块内存与 结构体 绑定在一起，
//      所以一旦在 使用的 地方定义了，
//      那么里面的 字段 会直接占用 一块大内存，
//      而 类 不管多大，都只在内部 存放引用
public struct StructExample
{
    // 结构体内 的 字段分布情况 与 类 一致
    private int a; // 内存空间
    private Tuple<int> b; // 引用
    
    private int[] c; // 引用
    private Tuple<int>[] d; // 引用 
    
    public void Foo()
    {
        a = 1; // 值类型的赋值操作，不涉及 新内存
        b = new Tuple<int>(5); // 在堆上，开辟一块内存，存放类的字段，
        c = new int[5]; // 在堆上，开辟一块连续内存，直接存放 值类型
        d = new Tuple<int>[5]; // 在堆上，开辟一块连续内存，存放数组的引用，对 item 赋值时，等号右边是一块新内存，数组的引用指向这块内存
    }
}

// 方法体内的 局部 变量与 在类或在结构体 无关
public class FuncExample
{
    /// 内存分析
    public void Foo()
    {
        // 栈上 第一次 分配一块内存，压栈，作用域为整个方法
        // 栈内存情况 a
        int a;  
        
        // 栈上 第二次 分配一块内存，存放引用，压栈，作用域为整个方法
        // 栈内存情况 a、b
        Tuple<int> b; 
        
        // 栈上 第三次 分配一块内存，存放数组引用，压栈，作用域为整个方法
        // 栈内存情况 a、b、c
        int[] c; 
        
        // 栈上 第四次 分配一块内存，存放数组引用，压栈，作用域为整个方法
        // 栈内存情况 a、b、c、d
        Tuple<int>[] d; 

        // 堆上 第一次 分配一块内存，存放类的字段等，字段里的 item1 里的数据内存被设置成 1
        // 栈内存情况 a、b、c、d 堆内存开辟的空间次数 1 
        b = new Tuple<int>(1);
        {
            // 栈上 第五次 分配一块内存，存放数组引用，压栈，作用域为 {}
            // 栈内存情况 a、b、c、d、e 堆内存开辟的空间次数 1 
            Tuple<int>[] e; 
            
            // 堆上 第二次 分配一块内存，是一块连续的内存，存放数组的数据内存
            // 栈内存情况 a、b、c、d、e 堆内存开辟的空间次数 2
            c = new int[5];

            // 堆上 第三次 分配一块内存，是一块连续的内存，存放 tuple数组的引用
            // 栈内存情况 a、b、c、d、e 堆内存开辟的空间次数 3
            d = new Tuple<int>[5];
            
            // 堆上 第四次 分配一块内存，并将 d[0] 的引用指向 这块内存
            // 栈内存情况 a、b、c、d、e 堆内存开辟的空间次数 4
            d[0] = new Tuple<int>(1);
            
            // 堆上 第五次 分配一块内存，并将 d[0] 的引用指向，这块内存
            // 栈内存情况 a、b、c、d、e 堆内存开辟的空间次数 5
            d[0] = new Tuple<int>(2);
            
        } // e 的作用域结束了，出栈
          // 栈内存情况 a、b、c、d 堆内存开辟的空间次数 5
        
        return; // d、c、b、a 先后出栈
        
        // 堆上开辟的内存 等待 GC 回收
    }
}

